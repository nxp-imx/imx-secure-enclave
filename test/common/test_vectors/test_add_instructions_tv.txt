
Description Note about the steps/format needed to be followed while
adding Tests in test vector file.

NOTE: The test vector filename with full PATH needs to be provided when
running the ele_hsm_test application.
Format: ele_hsm_test <tv_file_path>

If the <tv_file_path> not provided, then default tv file is used to run tests.

The file contains tests with the tags and follow the format described here.

NOTE: Currently Supports test vectors for: KGEN, CIPHER, MAC, Signature
Generation & Signature Verification, HASH, Data Storage


The test file is read line by line till EOF, to identify and use certain
lines/values. The lines which does not contain Recognized tags, get skipped.

The various tags used for representing start and stop of
services/operations/actions, parameter names etc. currently being used
are mentioned in below. Later more may get added.


Some Limitations about the format:

-	ALl Recognized Tags like TESTS_START, TESTS_END, TEST_KGEN_*, TEST_KGEN_END,
	TEST_CIPHER_*, TEST_CIPHER_END, TEST_MAC_*, TEST_MAC_END, TEST_SIGN_VERIFY_*,
	TEST_SIGN_VERIFY_END, TEST_HASH_*, TEST_HASH_END, TEST_DATA_STORAGE_*,
	TEST_DATA_STORAGE_END, LOAD_PERSIST_KEY_INFO, KEY_TV_ID, PERMITTED_ALGO,
	KEY_USAGE, etc. needs to start from very beginning of their line as these
	tags get read from very start of the line.

-	Only Spaces (Not tabs) need to be used for PARAM_NAME  'space' PARAM_VALUE
	key value pair.

-	OPEN_KEY_MGMT_SRV, CLOSE_KEY_MGMT_SRV, Buffer Inputs expect the input
	value in the just immediate next line of these/their tags.



------------------------------------------------------------------------
FORMAT for Test start of tests in test vector file:
------------------------------------------------------------------------

TESTS_START


-------------------------------------------------------------------------
FORMAT for ending the Tests started with TESTS_START:
-------------------------------------------------------------------------

TESTS_END


-------------------------------------------------------------------------
FORMAT for Opening Key Management service:
-------------------------------------------------------------------------

OPEN_KEY_MGMT_SRV
KEY_MGMT_TV_ID (only Value in the next line of the OPEN_KEY_MGMT_SRV tag)

E.g.

OPEN_KEY_MGMT_SRV
1234           #KEY_MGMT_TV_ID



-------------------------------------------------------------------------
FORMAT for Closing Key Management service opened with OPEN_KEY_MGMT_SRV:
-------------------------------------------------------------------------

CLOSE_KEY_MGMT_SRV
KEY_MGMT_TV_ID (only Value in the next line of the CLOSE_KEY_MGMT_SRV tag)

E.g.

CLOSE_KEY_MGMT_SRV
1234           #KEY_MGMT_TV_ID



------------------------------------------------------------------------
Tests of different test types/categories like KGEN (Key Generation),
CIPHER etc. can be added with following FORMAT:
------------------------------------------------------------------------

TEST_<Test_Type>_<PSA/NON_PSA>_<m><n>   #TEST_<Test_Type> marks Start of Test
The represents the start of a ELE HSM API test

PARAM_NAME   <spaces>   PARAM_VALUE     #Comments (If any)

NOTE: Space ' ', are important and tabs cannot be used, as Space is tokenizing
character for getting parameter name and its value

TEST_<Test_Type>_END                    #marks the end of test


'm' representing test type
0 - KGEN
1 - CIPHER
2 - MAC
3 - SIGN_VERIFY
4 - HASH
5 - DATA_STORAGE

'n' representing serial no of test of particular test type/category
1, 2, 3,...so on

PSA/NON_PSA in Test Name is for checking whether to run test case or skip
if not compatible with application compliance

E.g.

# KGEN Test
TEST_KGEN_PSA_001          #TEST_KGEN in beginning marks KGEN test start
PARAM_NAME PARAM VALUE     #Key-Value pair of Param Names and Values
PARAM_NAME PARAM VALUE
...
TEST_KGEN_END              #End



------------------------------------------------------------------------
FORMAT for Test Parameter which is a Input Buffer:
------------------------------------------------------------------------

INPUT_SIZE         DEC       #Input Size for Buffer
INPUT_DATA         DEC       #INPUT_DATA DEC value is the same INPUT_SIZE
Input Buffer with uint8_t (0x01, 0x02,....) separated with ', '

NOTE: The buffer needs to be provided from the immediate next line just
after INPUT_DATA tag is encountered.

INPUT_DATA/INPUT_SIZE are just placeholders and actual param names has to be
used according to tests

NOTE: INPUT_SIZE must be given before INPUT_DATA to allocate memory



------------------------------------------------------------------------
FORMAT and PARAMETERS for KGEN Tests:
------------------------------------------------------------------------

LOAD_PERSIST_KEY_INFO #(optional)If Persistent Keys are being tested

#Positive/Negative Case - Test Description (Optional line)
TEST_KGEN_<PSA/NON_PSA>_0<n>   #Marks Start of this one particular KGEN test

#PARAM_NAME       #PARAM_VALUE    #this line is not part of test

KEY_MGMT_TV_ID    DEC (uint32_t)  #Key Management ID to get Key Management hdl
KEY_TV_ID         DEC (uint32_t)  #Key TV ID to identify and use the key later
KEY_ID            HEX (uint32_t)  #Key ID is to be set to 0 in case of Volatile
OUT_SIZE          DEC (uint16_t)  #Output Public Key Size, 0 bytes for Symmetric Key
KEY_TYPE          HEX (uint16_t)  #Value of HSM Key Type to be used
BIT_KEY_SZ        HEX (uint16_t)  #Key Size bits
FLAGS             HEX (uint8_t)   #Flags for operation
KEY_GROUP         DEC (uint16_t)  #Value of Key Group out of range 0-1023
KEY_LIFETIME      HEX (uint32_t)  #Value of Key Lifetime
KEY_LIFECYCLE     HEX (uint32_t)  #Define device lifecycle in which key usable
KEY_USAGE         HEX (uint32_t)  #Calculated combined value of Key Usages needed
PERMITTED_ALGO    HEX (uint32_t)  #Value of Permitted Algo
EXPECTED_HSM_RESP HEX (uint8_t)   #Value of Expected HSM Response

TEST_KGEN_END                     #Marks the End of this one particular KGEN test


#DEC - DECimal value, HEX - HEXadecimal value (0x...)

NOTE: The Keys are saved so that it can used later through KEY_TV_ID by tests
(such as CIPHER, MAC) which may need the same key for their operations.
KEY_TV_ID is unique in KGEN test vectors.


NOTE:

In Case of Generating Persistent Keys, LOAD_PERSIST_KEY_INFO token is to be
used before the start of the Test vector of Persistent Key Generation.

The test of Persistent Key needs two runs of ele_hsm_test binary application,
to confirm the test of Persistent Key being stored and retrieved correctly.

1st run
Persistent Key gets generated and Get Key Attributes API called.
For usage of this generated Persistent Key, in later runs, a file carrying
required information (KEY_TV_ID KEY_IDENTIFIER space separated value pair)
is created under directory, /var/lib/se/persistent/. The generated persistent
key details or the content can be viewed using 'cat' command on the stored file.

2nd run
The Persistent Keys Information is read from the file created under
/var/lib/se/persistent/ in 1st run. KEY_TV_IDs and KEY_IDENTIFIERs of
peristent keys generated through test vectors are now known i.e. loaded in the
array containing records of active test vector generated keys identifiers.
No key is generated for the test_vectors having one of these KEY_TV_IDs.
For checking the availability of these Persistent keys, only Get Key
Attributes API is used. If the API results in SUCCESS, then the Persistent Key
is available without generating, otherwise test gets FAILED.



-------------------------------------------------------------------------
FORMAT and PARAMETERS for CIPHER Tests:
-------------------------------------------------------------------------

#Positive/Negative Case - Test Description (Optional line)
TEST_CIPHER_<PSA/NON_PSA>_1<n>

KEY_MGMT_TV_ID    DEC (uint32_t)  #Key Management TV ID to get Key Management hdl
KEY_TV_ID         DEC (uint32_t)  #Key TV ID from KGEN Tests to use the key
IV_SIZE           DEC (uint16_t)  #IV Size provided before IV data

IV_DATA           DEC (again IV_SIZE) #Next line have ', ' separated values
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F

#(Example of Input buffer format is given as above, buffer of 'uint8_t' values)

INPUT_SIZE        DEC (uint32_t)  #Plaintext/Input size to allocate memory

INPUT_DATA        DEC (again INPUT_SIZE) #Next line have ', ' separated values
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F

#( buffer of 'uint8_t' values)

OUTPUT_SIZE       DEC (uint32_t)  #Ciphertext/Output size
CIPHER_ALGO       HEX (uint32_t)  #Value of Cipher Algorithm to be used
EXPECTED_HSM_RESP HEX (uint8_t)   #Expected HSM Response

TEST_CIPHER_END



-------------------------------------------------------------------------
FORMAT and PARAMETERS for MAC Tests:
-------------------------------------------------------------------------

#Positive/Negative Case - Test Description (Optional line)
TEST_MAC_<PSA/NON_PSA>_2<n>

KEY_MGMT_TV_ID    DEC (uint32_t)  # Key Management TV ID to get Key Management hdl
KEY_TV_ID         DEC (uint32_t)  # Key TV ID from KGEN Tests to use the key
MAC_ALGO          HEX (uint32_t)  # MAC algorithm to be used
PAYLOAD_SIZE      DEC (uint32_t)  # Payload size to allocate memory

PAYLOAD_DATA      DEC (uint32_t)  # Payload data-Payload size for input
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3

#(Example of Input buffer format is given as above, 'uint8_t' HEX values)

MAC_SIZE     DEC (uint16_t) # MAC buffer size, allocates memory for MAC data

# Expected output MAC size is valid for case, when MAC API MAC Generation Resp
# (also Expected Resp) is HSM_NO_ERROR, HSM_OUT_TOO_SMALL or HSM_GENERAL_ERROR
EXP_MAC_SIZE      DEC (uint16_t)  # Expected output MAC size

# Expected MAC Verification status, valid if Verification op flag is set.
EXP_VERIFICATION_STATUS HEX (uint32_t) # Expected MAC API verification status

EXP_MAC_GEN_HSM_RESP    HEX (uint8_t)  # Expected HSM Resp for MAC Generation
EXP_MAC_VERIFY_HSM_RESP HEX (uint8_t)  # Expected HSM Resp for MAC Verification

TEST_MAC_END



------------------------------------------------------------------------------
FORMAT and PARAMETERS for Signature Generation & Signature Verification Tests:
------------------------------------------------------------------------------

#Positive/Negative Case:
#Test Description (Optional line)

TEST_SIGN_VERIFY_<PSA/NON_PSA>_3<n>

KEY_TV_ID         DEC (uint32_t)  # Key TV ID from KGEN Tests to use the key
MESSAGE_SIZE      DEC (uint32_t)  # Message size of input message

MESSAGE           DEC (uint32_t)  # Message-Message size for input buffer
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3

#(Example of Input buffer format is given as above, 'uint8_t' HEX values)

SIGNATURE_SIZE    DEC (uint16_t)   # Signature buffer size
SALT_LEN          DEC (uint16_t)   # Salt length in bytes
SCHEME_ID         HEX (uint32_t)   # Scheme to be used for the operation
SIGN_GEN_FLAGS    HEX (uint8_t)    # Signature Generation flags
SIGN_VERIFY_FLAGS HEX (uint8_t)    # Signature Verification flags
PKEY_TYPE         HEX (uint32_t    # Public Key Type
KEY_SIZE          DEC (uint16_t)   # Input public key size in bytes
BIT_KEY_SZ        DEC (uint16_t)   # Key security size in bits

# Expected output Signature size is valid for case, when Signature Generation
# API Resp (also Expected Resp) is HSM_NO_ERROR, HSM_OUT_TOO_SMALL
# or HSM_GENERAL_ERROR
EXP_SIGNATURE_SIZE      DEC (uint16_t) # Expected output signature size

# Expected Signature Verification status
EXP_VERIFICATION_STATUS HEX (uint32_t) # Expected Signature Verification status

EXP_SIGN_GEN_RSP    HEX (uint8_t)  # Expected Signature Generation HSM Resp
EXP_SIGN_VERIFY_RSP HEX (uint8_t)  # Expected Signature Verification HSM Resp

TEST_SIGN_VERIFY_END



-------------------------------------------------------------------------
FORMAT and PARAMETERS for HASH Tests:
-------------------------------------------------------------------------

#Positive/Negative Case:
#Test Description (Optional line)
TEST_HASH_<PSA/NON_PSA>_4<n>

HASH_ALGO         HEX (uint32_t)  #HASH algorithm to be used
FLAGS             HEX (uint8_t)   #Operation Flags
INPUT_SIZE        DEC (uint32_t)  #Input Size provided before Input Data buffer

INPUT_DATA        DEC (again INPUT_SIZE) #Next line have ', ' separated values
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,

#(Example of Input buffer format is given as above, buffer of 'uint8_t' values)
CTX_SIZE          DEC (uint16_t)  #Context Size provided before Context buffer
INPUT_CTX         DEC (again CTX_SIZE) #Input Context Buffer

OUTPUT_SIZE       DEC (uint32_t)  #Output Size
EXP_CTX_SIZE      DEC (uint16_t)  #Expected Context Size
EXP_OUTPUT_SIZE   DEC (uint32_t)  #Expected Output Size

EXP_OUTPUT_BUF    DEC (Output buffer size) #Next line have ', ' separated values
0x55, 0x4D, 0x5E, 0xED, 0x37, 0x31, 0x6F, 0xCA,
0xD7, 0x08, 0x72, 0x54, 0x4E, 0x05, 0x8C, 0xD4,
0xFC, 0x9E, 0x1C, 0x68, 0xE3, 0xDA, 0x18, 0x29,
0x44, 0x39, 0xB4, 0xAA,

#( buffer of 'uint8_t' values)

EXP_HASH_HSM_RESP   HEX (uint8_t) #Expected HASH API HSM Response

TEST_HASH_END


NOTE: Currently, only One Shot operation (flag = 0x1) HASH tests are supported
through test vectors. Context is of no use in this case.

-------------------------------------------------------------------------
FORMAT and PARAMETERS for DATA STORAGE Tests:
-------------------------------------------------------------------------

#Positive/Negative Case:
#Test Description (Optional line)
TEST_DATA_STORAGE_<PSA/NON_PSA>_5<n>_<a/b>

DATA_ID           HEX (uint32_t)  #Identifier of the data block
DATA_SIZE         DEC (uint32_t)  #Data Size provided before input Data buffer

DATA       	DEC (again mention DATA_SIZE) #Next line have ', ' separated values
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,

#(Example of Input buffer format is given as above, buffer of 'uint8_t' values)
#For STORE flag, it is the Data to be stored, while for RETRIEVE flag, it is
#the Expected Data to be used for matching with the Retrieved data using Data ID

FLAGS             HEX (uint8_t)  #Flags for operation (0x0 - Retrieve, 0x1 - Store)
EXP_DATA_STORAGE_HSM_RESP HEX (uint8_t) #Expected Data Storage API HSM Response

TEST_DATA_STORAGE_END


NOTE: The last part 'a' and 'b' of Test Identifier string, indicates STORE and
RETRIEVE Data respectively.




-------------------------------------------------------------------------
Example of a Complete Test:
-------------------------------------------------------------------------

#TestVector Tests Example


TESTS_START


OPEN_KEY_MGMT_SRV
1234     #Key Management ID, KEY_MGMT_TV_ID to be used by tests


#Key Generation test

#Positive Case
TEST_KGEN_PSA_001

KEY_MGMT_TV_ID    1234       # Key Management TV ID to get Key Mgmt hdl
KEY_TV_ID         1          # Key TV ID to use the key later
KEY_ID            0x0        # Key ID set to 0 for Volatile
OUT_SIZE          0          # Symmetric Key. So, Public Key Out Size 0
KEY_TYPE          0x2400     # HSM_KEY_TYPE_AES
BIT_KEY_SZ        256        # HSM_KEY_SIZE_AES_256
FLAGS             0          #
KEY_GROUP         1          # Key Group b/w range 0-1023
KEY_LIFETIME      0x00000100 # HSM_SE_KEY_STORAGE_VOLATILE
KEY_LIFECYCLE     0x0        # 0 indicates set to current Device Lifecycle
KEY_USAGE         0x00000300 # HSM_KEY_USAGE_ENCRYPT | HSM_KEY_USAGE_DECRYPT
PERMITTED_ALGO    0x84C0FF00 # PERMITTED_ALGO_ALL_CIPHER
EXPECTED_HSM_RESP 0x00       # HSM_NO_ERROR

TEST_KGEN_END


#Key Generation Tests - Persistent Key

#Load Persistent Key Info (KEY_TV_ID, KEY_IDENTIFIER) from persistent key
#details stored previously
LOAD_PERSIST_KEY_INFO


#Positive Case
#Test Generate Key API for Persistent Key Generation or Usage in getting
#Key Attributes if already generated
TEST_KGEN_PSA_012

KEY_MGMT_TV_ID    1234       # Key Management ID
KEY_TV_ID         12         # Key TV ID to use the key later
KEY_ID            0x0        # Key ID 0 for Volatile Key
OUT_SIZE          0          # Symmetric Key. So, Public Key Out Size 0
KEY_TYPE          0x2400     # HSM_KEY_TYPE_AES
BIT_KEY_SZ        256        # HSM_KEY_SIZE_AES_256
FLAGS             0x80       # HSM_OP_KEY_GENERATION_FLAGS_STRICT_OPERATION
KEY_GROUP         4          # Key Group b/w 0-1023
KEY_LIFETIME      0x00000101 # HSM_SE_KEY_STORAGE_PERSISTENT
KEY_LIFECYCLE     0x0        # 0 indicates set to current Device Lifecycle
KEY_USAGE         0x00000300 # HSM_KEY_USAGE_ENCRYPT | HSM_KEY_USAGE_DECRYPT
PERMITTED_ALGO    0x84C0FF00 # PERMITTED_ALGO_ALL_CIPHER
EXPECTED_HSM_RESP 0x00       # HSM_NO_ERROR

TEST_KGEN_END


#Test for Generating Key with KEY_TV_ID 101 to be used by Cipher Test

#Positive Case - Cipher Test KGEN
TEST_KGEN_PSA_101

KEY_MGMT_TV_ID     1234        # Key Management ID
KEY_TV_ID          101         # Key TV ID to use the key later
KEY_ID             0x0         # Key ID set to 0 for Volatile
OUT_SIZE           0           # Symmetric Key. So, Public Key Out Size 0
KEY_TYPE           0x2400      # HSM_KEY_TYPE_AES
BIT_KEY_SZ         256         # HSM_KEY_SIZE_AES_256
FLAGS              0           #
KEY_GROUP          1           # Key Group b/w 0-1023
KEY_LIFETIME       0x00000100  # HSM_SE_KEY_STORAGE_VOLATILE
KEY_LIFECYCLE      0x0         # 0 indicates set to current Device Lifecycle
KEY_USAGE          0x00000300  # HSM_KEY_USAGE_ENCRYPT | HSM_KEY_USAGE_DECRYPT
PERMITTED_ALGO     0x04404000  # PERMITTED_ALGO_CBC_NO_PADDING
EXPECTED_HSM_RESP  0x00        # HSM_NO_ERROR

TEST_KGEN_END



#CIPHER test using the key with KEY_TV_ID 101

#Positive Case
TEST_CIPHER_PSA_101

KEY_MGMT_TV_ID    1234        # Key Management TV ID
KEY_TV_ID         101         # Key TV ID from KGEN Tests to use the key
IV_SIZE           16          # IV Size provided before IV data

IV_DATA           16          # IV data-IV size take input from next line
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F

INPUT_SIZE        32          # Plaintext size to allocate memory

INPUT_DATA        32          # Plaintext size to take input from next line
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F

OUTPUT_SIZE       32          # Ciphertext/output size
CIPHER_ALGO       0x04404000  # HSM_CIPHER_ONE_GO_ALGO_CBC
EXPECTED_HSM_RESP 0x00        # HSM_NO_ERROR

TEST_CIPHER_END



#Test for Generating Key with KEY_TV_ID 201 to be used by MAC test


#Positive Case
TEST_KGEN_PSA_201

KEY_MGMT_TV_ID    1234       # Key Management ID
KEY_TV_ID         201        # Key TV ID to use the key later
KEY_ID            0x0        # Key ID 0 for Volatile Key
OUT_SIZE          0          # Symmetric Key. So, Public Key Out Size 0
KEY_TYPE          0x2400     # HSM_KEY_TYPE_AES
BIT_KEY_SZ        256        # HSM_KEY_SIZE_AES_256
FLAGS             0          #
KEY_GROUP         3          # Key Group b/w 0-1023
KEY_LIFETIME      0x00000100 # HSM_SE_KEY_STORAGE_VOLATILE
KEY_LIFECYCLE     0x0        # 0 indicates set to current Device Lifecycle
KEY_USAGE         0x00000C00 # HSM_KEY_USAGE_SIGN_MSG | HSM_KEY_USAGE_VERIFY_MSG
PERMITTED_ALGO    0x03C00200 # PERMITTED_ALGO_CMAC
EXPECTED_HSM_RESP 0x00       # HSM_NO_ERROR

TEST_KGEN_END



#MAC test using the key with KEY_TV_ID 201

#Positive Case:
#Test MAC operation with CMAC algo using saved AES 256 Key permitted for CMAC

TEST_MAC_PSA_201

KEY_MGMT_TV_ID    1234       # Key Management TV ID
KEY_TV_ID         201        # Key TV ID from KGEN Tests to use the key
MAC_ALGO          0x03C00200 # PERMITTED_ALGO_CMAC
PAYLOAD_SIZE      32         # Payload Size provided before Payload data

PAYLOAD_DATA      32         # Payload data-Payload size, input from next line
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3

MAC_SIZE          16         # MAC buffer size
EXP_MAC_SIZE      16         # Expected MAC size
EXP_VERIFICATION_STATUS 0x6C1AA1C6u # HSM_MAC_VERIFICATION_STATUS_SUCCESS
EXP_MAC_GEN_HSM_RESP    0x00 # HSM_NO_ERROR
EXP_MAC_VERIFY_HSM_RESP 0x00 # HSM_NO_ERROR

TEST_MAC_END



CLOSE_KEY_MGMT_SRV
1234     #KEY_MGMT_TV_ID


TESTS_END




#Test for Generating Key with KEY_TV_ID 301 to be used by Signature Generation
#& Signature Verification test



#Positive Case:
TEST_KGEN_PSA_301

KEY_MGMT_TV_ID    1234       # Key Management ID
KEY_TV_ID         301        # Key TV ID to use the key later
KEY_ID            0x0        # Key ID 0 for Volatile Key
OUT_SIZE          56         # Public Key Out Size
KEY_TYPE          0x7112     # HSM_KEY_TYPE_ECC_NIST
BIT_KEY_SZ        224        # HSM_KEY_SIZE_ECC_NIST_224
FLAGS             0          #
KEY_GROUP         3          # Key Group b/w 0-1023
KEY_LIFETIME      0x00000100 # HSM_SE_KEY_STORAGE_VOLATILE
KEY_LIFECYCLE     0x0        # 0 indicates set to current Device Lifecycle
KEY_USAGE         0x00003000 # HSM_KEY_USAGE_SIGN_HASH | HSM_KEY_USAGE_VERIFY_HASH
PERMITTED_ALGO    0x06000608 # PERMITTED_ALGO_ECDSA_SHA224
EXPECTED_HSM_RESP 0x00       # HSM_NO_ERROR

TEST_KGEN_END



#Signature Generation & Signature Verification test using key KEY_TV_ID 301

#Positive Case:
#Test Signature Generation & Verification operation with ECC NIST 224 key,
#and ECDSA SHA224 algorithm
TEST_SIGN_VERIFY_PSA_301

KEY_TV_ID         301        # Key TV ID from KGEN Tests to use the key
MESSAGE_SIZE      28         # Message Size provided before Payload data

MESSAGE           28         # Message-Message size, input from next line
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1A, 0x1B,

SIGNATURE_SIZE    56         # Signature size
SALT_LEN          0          # Salt length in bytes
SCHEME_ID         0x06000608 # HSM_SIGNATURE_SCHEME_ECDSA_SHA224
SIGN_GEN_FLAGS    0x0        # HSM_OP_GENERATE_SIGN_FLAGS_INPUT_DIGEST
SIGN_VERIFY_FLAGS 0x0        # HSM_OP_VERIFY_SIGN_FLAGS_INPUT_DIGEST
PKEY_TYPE         0x4112     # HSM_PUBKEY_TYPE_ECC_NIST
KEY_SIZE          56         # Public Key Byte Size
BIT_KEY_SZ        224        # HSM_KEY_SIZE_ECC_NIST_224
EXP_SIGNATURE_SIZE 56        # Expected Signature Size in API Resp
EXP_VERIFICATION_STATUS 0x5A3CC3A5 # HSM_VERIFICATION_STATUS_SUCCESS
EXP_SIGN_GEN_RSP  0x0        # HSM_NO_ERROR
EXP_SIGN_VERIFY_RSP 0x0      # HSM_NO_ERROR

TEST_SIGN_VERIFY_END




#HASH test

#Positive Case:
#Test HASH op for HSM_HASH_ALGO_SHA_224
TEST_HASH_PSA_401

HASH_ALGO         0x02000008   #HSM_HASH_ALGO_SHA_224
FLAGS             0x1          #One shot HASH op
CTX_SIZE          0            #Context size
INPUT_CTX         0            #Input Context
INPUT_SIZE        300          #Input Size

INPUT_DATA        300          #Input Data-Input Size, buffer from next line
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0,

OUTPUT_SIZE            28      # Output Size
EXP_CTX_SIZE           0       # Expected Context Size
EXP_OUTPUT_SIZE        28      # Expected Output Size

EXP_OUTPUT_BUF         28      # Expected Output-Buffer Size, input next line
0x55, 0x4D, 0x5E, 0xED, 0x37, 0x31, 0x6F, 0xCA,
0xD7, 0x08, 0x72, 0x54, 0x4E, 0x05, 0x8C, 0xD4,
0xFC, 0x9E, 0x1C, 0x68, 0xE3, 0xDA, 0x18, 0x29,
0x44, 0x39, 0xB4, 0xAA,

EXP_HASH_HSM_RESP       0x00   # HSM_NO_ERROR

TEST_HASH_END




#Data Storage Tests



#Positive Case:
#Store Data of size 60 bytes
TEST_DATA_STORAGE_PSA_501_a

DATA_ID       0x02       # Data ID
DATA_SIZE     60         # Data size in bytes
DATA          60         # Data-Data size, data buffer next line
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x79, 0xC6, 0xDF, 0xDF

FLAGS          0x1        # HSM_OP_DATA_STORAGE_FLAGS_STORE
EXP_DATA_STORAGE_HSM_RESP 0x00    # HSM_NO_ERROR

TEST_DATA_STORAGE_END



#Positive Case:
#Retrieve Stored Data of size 60 bytes
TEST_DATA_STORAGE_PSA_501_b

DATA_ID       0x02       # Data ID
DATA_SIZE     60         # Data size in bytes
DATA          60         # Data-Data size, data buffer next line
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0xFE, 0x7E, 0xD8, 0xDB, 0x7A, 0x26,
0x2B, 0x9D, 0xA7, 0xE0, 0x7C, 0xCB, 0x0E, 0xA9,
0xF4, 0x74, 0x7B, 0x8C, 0xCD, 0xA8, 0xA4, 0xF3,
0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
0xB2, 0xE1, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x85, 0xF4, 0x4C, 0x5C, 0x79, 0xC6, 0xDF, 0x5B,
0x79, 0xC6, 0xDF, 0xDF

FLAGS          0x0        # HSM_OP_DATA_STORAGE_FLAGS_RETRIEVE
EXP_DATA_STORAGE_HSM_RESP 0x00  # HSM_NO_ERROR

TEST_DATA_STORAGE_END


-------------------------------------------------------------------------

